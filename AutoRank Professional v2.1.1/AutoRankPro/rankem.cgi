#!/usr/bin/perl
####################################
##  AutoRank Professional v2.1.1  ##
###############################################################
##  rankem.cgi                                               ##
##  ----------                                               ##
##  This script tracks incoming hits.                        ##
###############################################################

###############################################################
##                   DO NOT EDIT THIS FILE                   ##
###############################################################

package rank;

use strict;
use GDBM_File;

$rank::sd_dir = "./sdata";
$rank::md_dir = "./members";

my($qry, %mem, %data, $forward);

if($ENV{'REQUEST_METHOD'} eq "GET") {
  eval {
    require "$rank::sd_dir/vars.dat";
    
    if( $OPT::RND ) {
      my @pages = split(/,/, $VAR::PL);
      my $one = int( rand( scalar( @pages ) ) );
      $forward = $VAR::HU . "/" . $pages[$one];
    }
    else {
      $forward = $VAR::FU;
    }
    
    $qry = parse_query();
    
    *function = lc( $qry->{'action'} );
    
    error("rankem.cgi", "rank::main()", "No Action Selected") if( $qry->{'action'} eq "" );
    
    &function();
  };

  if($@) {
    print "Content-type: text/html\n\n";
    print "<b>Script Error:</b> $@"
  }
}
else {
  print "Invalid access method";
}

exit;

sub in {
  if( int($OPT::DBL) ) {
    print "Content-type: text/html\n\n";
    print <<HTML;
    <html>
    <head>
      <title>Enter</title>
    </head>
    <body>
    <div align="center">
    <h2>Enter This Site</h2>
    Click here to <a href="$VAR::CU/rankem.cgi?action=incheck&id=$qry->{'id'}">enter</a>.
HTML
  }
  else {
    give_hit( $qry->{'id'} );
  }
}

sub incheck {
  if( $ENV{'HTTP_REFERER'} =~ /rankem.cgi\?action=in/i ) {
    give_hit( $qry->{'id'} );
  }
  else {
    log_cheat("Double Cheat") if( $OPT::CHT );
    check_time() unless( defined $OPT::CRN );
    print "Location: $forward\n\n";
  }
}

sub give_hit {
  my $acct = shift;
  
  dbmopen(%mem, "$rank::sd_dir/members", 0666) || error("members", "rank::give_hit()", $!);
  
  if( defined( $mem{$acct} ) ) {
    my @md = split(/\|/, $mem{$acct});
    
    if( $md[16] ne $ENV{'REMOTE_ADDR'} ) {
      $md[0]++;
      $md[2] = 0;
      $md[16] = $ENV{'REMOTE_ADDR'};

      $mem{$acct} = join('|', @md);
    }
    else {
      log_cheat("Multiple Click") if( $OPT::CHT );
    }
  }
  
  dbmclose( %mem );
  
  check_time() unless( defined $OPT::CRN );
  
  print "Location: $forward\n\n";
}

sub check_time {
  require "functions.cgi";
  
  dbmopen(%data, "$rank::sd_dir/info", 0666) || error("info", "rank::check_time()", $!);
  
  my $rerank = $data{'rerank'};
  my $reset  = $data{'reset'};
  my $rrfrom = $data{'rrfrom'};
  my $rsfrom = $data{'rsfrom'};
  
  dbmclose(%data);
  
  if( (time - $rerank) >= $VAR::RR ) { 
    fnct::writelist( fnct::getsorted() );
    $rerank = time;
    $rrfrom = "rankem.cgi";
  }
  
  if( (time - $reset) >= $VAR::RS ) {
    resetlist();
    $reset  = time;
    $rsfrom = "rankem.cgi";
  }
  
  dbmopen(%data, "$rank::sd_dir/info", 0666) || error("info", "rank::check_time()", $!);
  
  $data{'rerank'} = $rerank;
  $data{'reset'}  = $reset;
  $data{'rrfrom'} = $rrfrom;
  $data{'rsfrom'} = $rsfrom;

  dbmclose( %data );
}

sub resetlist {
  my $sorted = fnct::getsorted(1);
  my($date, $in, $out, $rank);
  my $junk = pop( @{ $sorted } );
  $junk = pop( @{ $sorted } );
  my @tb  = localtime;
  
  $tb[5] += 1900;

  dbmopen(%mem, "$fnct::sd_dir/members", 0666) || error("member", "rank::reset_list()", $!);
  
  my $count = 1;
  for( @{ $sorted } ) {
    my @md = split( /\|/, $mem{$_} );
    
    open(STATS, ">>$fnct::md_dir/$_.sts") || error("$_.sts", "rank::reset_list()", $!);
    format STATS =
@<<<<<<<<   @<<<<<<<<<<   @<<<<<<<<<<  @<<<<<
$date,      $in,          $out,        $rank
.
    $date = $tb[4] + 1 . "." . $tb[3] . "." . $tb[5];
    $in = $md[0];
    $out = $md[1];
    $rank = "$count\n";
    write STATS;
    close(STATS);
    
    $md[4] = $count;
    $md[3] = $md[0];
    $md[2]++ if( $md[0] eq "0" );
    $md[0] = 0;
    $md[1] = 0;
    $md[16] = "0.0.0.0";
    
    $mem{$_} = join('|', @md);
    $count++;
  }
  
  dbmclose(%mem);
}

sub parse_query {
  my @pairs = split(/&/, $ENV{'QUERY_STRING'});
  my ($name, $value);
  my %query = ();
  
  for (@pairs) {
    ($name, $value) = split(/=/, $_);
    $query{$name} = $value;
  }
  return \%query;
}

sub log_cheat {
  my $type = shift;
  
  open(ERRLOG, ">>$rank::sd_dir/cheat.log") || error("cheat.log", "rank::log_cheat()", $!);
  print ERRLOG "[ ", scalar(localtime()), " ]  [ $ENV{'REMOTE_ADDR'} ]  [ $type ]  [ $qry->{'id'} ]\n";
  close(ERRLOG);
}

sub error {
  my($file, $fnct, $cause) = @_;
  my $user  = (getpwuid( $< ))[0];
  my $group = (getgrgid( $) ))[0];
  
  if( $OPT::ERR && $cause !~ /resource/i ) {
    open(ERRLOG, ">>$rank::sd_dir/error.log");
    print ERRLOG "[ ", scalar(localtime()), " ]  [ $ENV{'REMOTE_ADDR'} ]  [ $file ]  [ $cause ]  [ $fnct ]\n";
    close(ERRLOG);
  }
  
  if( $cause =~ /resource/i ) {
    print "Location: $forward\n\n";
  }
  else {
    print "Content-type: text/html\n\n";
    print "<pre>\nA CGI ERROR HAS OCCURRED\n========================\n";
    print "Error Message     :  $cause\n";   
    print "Accessing File    :  $file\n";
    print "Calling Function  :  $fnct\n";
    print "Running as User   :  $user\n";
    print "Running as Group  :  $group\n";
    print "Script Filename   :  $ENV{'SCRIPT_FILENAME'}\n";
  }
  
  exit -1;
}
