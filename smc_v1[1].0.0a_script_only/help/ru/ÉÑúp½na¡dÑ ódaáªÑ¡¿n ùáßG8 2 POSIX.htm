<!-- Нажмите Alt+F4 -->
<html><head>
<title>Регулярные выражения. Часть 2. POSIX. -- Техника программирования -- версия для печати -- php в деталях</title>
<meta name="keywords" content="программирование php programming пхп php4 php3 zend html базы данных mysql php+mysql apache апач апаче phpmyadmin скрипт script array массив object объект объектно-ориентированное программирование ООП бесплатно free open source открытый источник код безопасность security">
<meta name="description" content="Детальное описание приёмов программирования PHP, примеры, бесплатные скрипты">

<link rel=stylesheet type=text/css href=/pict/all.css>
</head>
<body link=#0063a5 alink=#0063a5 vlink=#004385 bgcolor=#ffffff>
<h2>Полная версия выпуска: <a href=http://detail.phpclub.net/technique/01-02-07/>http://detail.phpclub.net/technique/01-02-07/</a></h2>
<h1>Регулярные выражения. Часть 2. POSIX.</h1>
<div class="info">DL<br>7.02.2001</div>
<p>Продолжаем наш разговор. Предыдущий выпуск был вводным, теорией. Сегодня как бы основная часть рассказа&nbsp;&#151; стандарт POSIX. В следующем выпуске я опишу различия, вернее сказать надстройки стандарта совместимого с perl.<br />
<br />
Итак, обо всем по порядку.</p><h2>Набор символов</h2><table width=100% cellpadding=4 cellspacing=0 border=1><tr><td valign=top>.</td><td valign=top>точка</td><td valign=top width=100%>любой символ</td></tr><tr><td valign=top>[&lt;символы&gt;]</td><td valign=top>квадратные скобки</td><td valign=top>класс символов ("любое из")</td></tr><tr><td valign=top>[^&lt;символы&gt;</i>]</td><td valign=top>&nbsp;</td><td valign=top>негативный класс символов ("любое кроме")</td></tr><tr><td valign=top>-</td><td valign=top>тире</td><td valign=top>обозначение последовательности в классе символов ("[0-9]"&nbsp;&#151; цифры)</td></tr></table><p>Особо объяснять ничего не нужно. Разве что следующее: не пользуйтесь классом символов для обозначения всего лишь одного (вместо "[ ]+" вполне сойдет " +"). Не пишите в классе символов точку&nbsp;&#151; это ведь любой символ, тогда другие символы в классе будут просто лишними (а в негативном классе получится отрицание всех символов).</p><h2>Квантификатор</h2><p>Это, как я уже писал, указатель количества заданных символов. Квантификатором можно указать как конкретное значение, так и пределы. Если число заданных подпадает под пределы квантификатора, фрагмент выражения считается совпавшим с разбираемой строкой. Синтаксис:<br />
<br />
{<i>&lt;количество&gt;</i>}<br />
<br />
либо<br />
<br />
{<i>&lt;минимум&gt;</i>, <i>&lt;максимум&gt;</i>}<br />
<br />
Если нужно указать только необходимый минимум, а максимума нет, просто ставим запятую и не пишем второе число: "{5,}" ("минимум 5"). Для наиболее часто употребляемых квантификаторов есть специальные обозначения:</p><table width=100% cellpadding=4 cellspacing=0 border=1><tr><td valign=top>*</td><td valign=top>"звёздочка" или знак умножения</td><td valign=top width=100%>{0,}</td></tr><tr><td valign=top>+</td><td valign=top>плюс</td><td valign=top>{1,}</td></tr><tr><td valign=top>?</td><td valign=top>вопросительный знак</td><td valign=top width=100%>{0,1}</td></tr></table><p>На практике такие символы используются чаще, чем фигурные скобки.</p><h2>Якоря</h2><table width=100% cellpadding=4 cellspacing=0 border=1><tr><td valign=top>^</td><td valign=top width=100%>привязка к началу строки</td></tr><tr><td valign=top>&#36;</td><td valign=top>привязка к концу строки</td></tr></table><p>Эти символы должны стоять соответственно в самом начале и в самом конце строки. Чтобы интерпретатор корректно понял символ <b>&#36;</b> в конце, желательно добавить к нему обратный слэш:<br />
<br />
ereg("foo&#36;", &#36;bar)</p><h2>Структура</h2><p>Сейчас будет сложное описание, мне оно и самому не нравится.<br />
<br />
Эта вещь необходима для сложных запросов. Например, вам надо, чтобы в тексте были либо только маленькие буквы, либо только большие, либо только цифры. Класс символов "[a-zA-Z0-9]" не подходит. Тогда пишем такое:<br />
<br />
if (ereg("[a-z]+|[A-Z]+|[0-9]+", &#36;text)) ...<br />
<br />
Вертикальная черта&nbsp;&#151; знак "или" регулярных выражений (знака "и", естественно, не существует&nbsp;&#151; это и есть само регулярное выражение). Разделенные вертикальной чертой шаблоны в официальной документации называются альтернативными ветвями (это подразумевает ветвление, т.е. наличие вложенных альтернативных ветвей). Программа сравнивает со строкой все ветви (проходясь по их ряду слева направо), до первого совпадения (это важно учесть, если у вас сложное выражение со вложенными ветвями). Для разделения уровней и отделения этого дерева альтернатив от остального шаблона используются обычные скобки. Если те же большие/маленькие буквы/цифры надо искать внутри контейнера тегов:<br />
<br />
if (ereg("&lt;tag&gt;([a-z]+|[A-Z]+|[0-9]+)&lt;/tag&gt;", &#36;text)) ...<br />
<br />
Из сложного это, кажется, все. Теперь о более простом. Скобки по-научному называются subpattern (вложенный шаблон). И используются не только для сложных вариантов шаблонов, но и для гибкой замены фрагментов текста или получения их в переменную. К примеру, для печатной версии текста дублируем адреса ссылок текстом в скобках:<br />
<br />
ereg_replace("&lt;a href=([^&gt;]+)&gt;[^&lt;]+&lt;/a&gt;", "  [1]", &#36;text);<br />
<br />
Первые скобки&nbsp;&#151; первый вложенный шаблон&nbsp;&#151; можно получить "на выходе" через обозначение "n" (поскольку обратный слэш в php и многих других языках используется для спецсимволов, надо поставить перед ним еще один такой же, чтобы прогамма понимала его буквально). Под нулевым номером&nbsp;&#151; вся совпавшая строка. У себя в печатной версии статьи я не пишу ссылки сразу в тексте, а делаю их список в конце примерно так:</p>if (ereg("&lt;a href=([^&gt;]+)&gt;([^&lt;]+)&lt;/a&gt;", &#36;text, &#36;match)) {<br />
&nbsp;&nbsp;for (&#36;a=0;&#36;a&lt;sizeof(&#36;match[0]);&#36;a++) {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&#36;b = &#36;a+1;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&#36;text = str_replace(&#36;match[0][&#36;a], &#36;match[0][&#36;a]." [&#36;b]", &#36;text);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&#36;match[1][&#36;a] = "&#36;b) ". &#36;match[1][&#36;a];<br />
&nbsp;&nbsp;&nbsp;&nbsp;};<br />
&nbsp;&nbsp;&#36;text .= "&lt;br&gt;&lt;h2&gt;Ссылки, использованные в выпуске:&lt;/h2&gt;". implode("&lt;br&gt;", &#36;match[1]);<br />
&nbsp;&nbsp;};<p>Функция ereg (и eregi), если ей указать в третьем параметре переменную, то туда будут записаны все подстроки в виде <a href=http://detail.phpclub.net/technique/01-01-13/>двухмерного массива</a> [1].<br />
<br />
Это, собственно, все. Дальше нужно только уметь составлять шаблоны. Приведу несколько примеров.<br />
<br />
1. <a href=http://detail.phpclub.net/technique/01-01-20/>Переписывание адресов сервером Apache</a> [2] (как я уже отметил, Apache работает со стандартом POSIX).<br />
<br />
2. <a href=http://detail.phpclub.net/technique/00-12-18/>Поиск по базе данных</a> [3]: из пользовательского поискового запроса делается sql-запрос. Если отбросить создание статистики поиска (сколько найдено всего, сколько по каждому слову), то получится, что необходимо всего 6-7 строк кода. Там же описана и подсветка слов в результатах поиска. Кстати, важное замечание: перед тем, как вырезать короткие слова из строки я заменяю пробелы между словами на двойные. Почему? Потому что совпадающие с шаблоном строки не должны наезжать друг на друга.<br />
<br />
Объясню подробнее. Если в шаблоне нет никаких якорей, система проходится по тексту слева направо, и если найдено совпадение, кидает его в какие-то переменные, а затем перескакивает на следующий символ после совпавшего фрагмента. Мы ищем по шаблону "пробел, два непробела, пробел", а пробелы одиночные. Программа находит "пробел-короткое слово-пробел", заменяет это на один пробел, а затем перескакивает на... первую букву следующего слова. Это не пробел, поэтому даже если следующее слово тоже короткое, оно под шаблон не подойдет. Поэтому-то и надо предварительно заменить пробелы на двойные.<br />
<br />
3. Как хранить новости в файлах и не бегать циклом по дате:</p>&#36;handle=opendir(&#36;newsdir);<br />
while (&#36;file = readdir(&#36;handle)) {<br />
&nbsp;&nbsp;if (is_file(&#36;file) && ereg("^[0-9]{6}.txt&#36;", &#36;file))<br />
&nbsp;&nbsp;&nbsp;&nbsp;print ("&lt;p align=justify&gt;&lt;b&gt;". ereg_replace("^([0-9]{2})([0-9]{2})([0-9]{2}).txt&#36;", "1.2.203", &#36;file). "&lt;/b&gt; ". implode("", file(&#36;file)). "&lt;/p&gt;");<br />
closedir(&#36;handle);<p>4. Проверка правильного написания email-а:</p>if (!eregi("^[a-z0-9._-]+@[a-z0-9._-]+.[a-z]{2,4}&#36;", &#36;email))<br />
&nbsp;&nbsp;print("Bad email: "&#36;email"");<p>На этом все. В следующем выпуске&nbsp;&#151; стандарт PCRE, точнее дополнительные возможности, которые он предоставляет.<br><h2>Ссылки, использованные в выпуске:</h2>1) http://detail.phpclub.net/technique/01-01-13/<br>2) http://detail.phpclub.net/technique/01-01-20/<br>3) http://detail.phpclub.net/technique/00-12-18/</p>

<br><br><h2>Полная версия выпуска: <a href=http://detail.phpclub.net/technique/01-02-07/>http://detail.phpclub.net/technique/01-02-07/</a></h2>
<hr>
&copy; Дмитрий Лебедев &lt;<a href=mailto:dnl@au.ru>dnl@au.ru</a>&gt;<br>
&copy; Клуб PHP-разработчиков &lt;<a href=http://phpclub.net>http://phpclub.net</a>&gt;
</body></html>