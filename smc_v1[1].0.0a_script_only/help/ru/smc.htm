<html>
<head>
<title>Solace MUD Client</title>
</head>
<body>

<h1>Solace MUD Client (SMC)</h1>
<i>(обновлена для версии 1.0.0a)</i>
<br><br>

<a href=#whatis>Что это такое?</a><br>
<a href=#where>Кто автор и где это скачать?</a><br>
<a href=#options>Настройки (smc.ini)</a><br>
<a href=#run>Как запустить?</a><br>
<a href=#regexp>Регулярные выражения</a><br>
<a href=#db_mysql>База данных MySQL</a><br>
<a href=#other_db>Другие базы данных</a><br>
<br>
<a href=#commands>Команды</a>
<ul>
<li><a href=#cmd_about>about</a>
<li><a href=#cmd_connect>connect</a>
<li><a href=#cmd_zap>zap</a>
<li><a href=#cmd_cr>cr</a>
<li><a href=#cmd_drop>drop</a>
<li><a href=#cmd_textin>textin</a>
<li><a href=#cmd_textout>textout</a>
<li><a href=#cmd_commands>commands</a>
<li><a href=#cmd_info>info</a>
<li><a href=#cmd_savelog>savelog</a>
<li><a href=#cmd_simul>simul</a>
<li><a href=#cmd_simulvars>simulvars</a>
<li><a href=#cmd_test>test</a>
<li><a href=#cmd_php>php</a>
<li><a href=#cmd_show>show</a>
<li><a href=#cmd_quite>quite</a>
<li><a href=#cmd_ignore>ignore</a>
<li><a href=#cmd_null>null</a>
<li><a href=#cmd_load>load</a>
<li><a href=#cmd_clear>clear</a>
<li><a href=#cmd_colors>colors</a>
<li><a href=#cmd_loop>loop</a>
<li><a href=#cmd_N>N</a>
<li><a href=#cmd_sql>sql</a>
<li><a href=#cmd_var>var</a>
<li><a href=#cmd_vasr>vars</a>
<li><a href=#cmd_alias>alias</a>
<li><a href=#cmd_aliases>aliases</a>
<li><a href=#cmd_hl>hl</a>
<li><a href=#cmd_hls>hls</a>
<li><a href=#cmd_trigger>trigger</a>
<li><a href=#cmd_triggers>triggers</a>
<li><a href=#cmd_action>action</a>
<li><a href=#cmd_actions>actions</a>
<li><a href=#cmd_prompt>prompt</a>
<li><a href=#cmd_sub>sub</a>
<li><a href=#cmd_subs>subs</a>
<li><a href=#cmd_gag>gag</a>
<li><a href=#cmd_gags>gags</a>
</ul>
<a href=#userfuncs>Функции пользователя</a>

<br><br>
<hr>
<a name=whatis>
<h2>Что это такое?</h2>
Клиент представляет собой скрипт, написанный на <a href="http://www.php.net">PHP</a>, позволяющий вашему telnet клиенту подсоединяться через него к MUD или к любому серверу через telnet.
Таким образом он работает по принципу прокси-сервера, обрабатывая данные, посылаемые в MUD и приходящие от него. SMC предоставляет весь набор современного mud-клиента: aliases, actions, highlights, gags, timer, speedwalks, logging и т.д., но на гораздо более высоком уровне и огромным количеством возможностей (в частности поддержка баз данных). На сегодняшний день PHP является самым мощным скриптовым языком для всех платформ, и продолжает стремительно развиваться. С помощью SMC вы можете задействовать все возможноти PHP при игре в MUD (или любом telnet-ориентированном приложении): поддержка большинства типов баз данных, регулярные выражения, бестиповые переменные, работа с интернет (sockets, ftp, http и др.) и т.д. Если вы еще не знаете, что такое PHP, то посмотрите его в поисковых системах. На данный момент в интернете имеется огромное количество литературы по PHP на любом языке. Чтобы полностью задействовать всю мощь скриптов вам необходимо хотя бы немного ознакомиться с синтаксисом PHP и <a href="Регулярные выражения (regexp) Часть 1.htm">регулярных выражений</a>.
<p>У SMC есть и другая особенность, для кого-то хорошая, для кого-то плохая. В силу того, что это по сути прокси-сервер, который может быть запущен у любого хостера предоставляющего PHP (версии 4.1.0 или выше с поддержкой sockets extension), то он может быть использован для подстановки другого IP адреса, если ваша подсеть забанена в MUDе. Праздник нарушителям и горе имморталам :)<br>
<p>Также SMC может быть использован в хакерских целях, отнюдь не имеющих никакого отношения к игре в мады.
Расширенные возможности обработки текстовых данных (точнее неограниченные), работа с базами данных,
подстановка чужих IP адресов (в случае запуска у хостера) делает SMC весьма эффективным оружием
в руках профессионального хакера для взлома любых серверов. Надеюсь, что клиент будет использован
только в "мирных" целях, и автор не несет ответственности за незаконное использование программы.<br>
<p>И последнее - это клиент, который может помочь вам в игре, и может быть не раз спасет вашу жизнь
(и заберет чужие :), поэтому рассчитан на серьезных игроков. Вследствие чего количество проверок
на недопустимые параметры сведено на минимум (так называемая "защита от дурака"), помните об этом,
когда захотите создать переменную с именем F444$%gr_g&e1...

<br><br>
<hr>
<a name=where>
<h2>Кто автор и где это скачать?</h2>
Автор: Зубов Илья (Zilav, Velice, Yehat, Nessit, ...)<br>
E-Mail:
<a href=mailto:solace@ezmail.ru>solace@ezmail.ru</a>,
<a href=mailto:zilav@allnetwork.ru>zilav@allnetwork.ru</a>
<br>
WWW: <a href="http://solace.allnetwork.ru/smc.php">http://solace.allnetwork.ru/smc.php</a><br>
Если вы нашли ошибки, что-то дописали или у вас есть просто какие-либо замечания и предложения, то
пишите мне на e-mail или в форум на сайте.<br>
Среда разработки: PII-466, 196MB, Win2k, редактор Aditor 3.10, под музыку Enya, Blackmore's Night, Era :)

<br><br>
<hr>
<a name=options>
<h2>Настройки (smc.ini)</h2>
В файле настроек возле каждой опции есть описание на английском. Если вы его не знаете, то как же вы тогда
играете в MUDы и зачем вам это клиент?<br>
<p>Настройки соединения:
<ul>
<li>listen_address - адрес и порт на котором ждать входящие соединения. SMC работает только с
одним соединением за раз, поэтому если играть собираются несколько человек, то просто
раскопируйте SMC по разным директориям и запустите несколько копий одновременно, при этом
не забудьте для каждой копии SMC указать разные порты ожидания соединения.
<li>mud_address - адрес и порт мада, к которому будет произведено автоматическое подключение
(если установлено). Также при команде !connect без параметров будет использован этот адрес.
<li>allowed_ip - маска адресов, с которых принимать соединения, например 192.168.0.*, 202.67.*.*.
Оставьте это поле пустым или *.*.*.* если проверка не требуется.
<li>password - парольная защита для входящих соединений. Оставьте пустым если не требуется.
<li>connect_to_mud - автоматическое подсоединение к маду, когда пользователь подсоединяется
к SMC. (0 или 1)
</ul>

<p>Настройки команд и вывода:
<ul>
<li>script_prefix - указанная строка будет добавлена к выводу SMC
<li>cmd_color - цвет вывода SMC
<li>cmd_prefix - символ-идентификатор команд SMC
<li>cmd_quite - символ-идентификатор блокировки вывода
<li>cmd_delimiter - символ-разделитель команд
<li>text_color - цвет текста мада по-умолчанию
<li>brackets - скобки для группировки параметров
</ul>

<p>Профайлы:
<ul>
<li>profile_extension - расширение профайлов
<li>default_profile - имя профайла по-умолчанию
</ul>

<p>Логи:
<ul>
<li>maxlogsize - размер лога в памяти, прежде чем он будет сохранен на диск
<li>logfile - имя файла для лога при автоматическом сохранении. Если пусто, то автосохранение отключено.
<li>logformat - формат лога при автосохранении (смотри команду !savelog).
<li>log_input - записывать в лог команды пользователя (0 или 1)
</ul>

<p>Форматы:
<ul>
<li>freg - имя функции для поиска регулярных выражений
<li>varformat - формат имени переменной в actions, subs.
<li>varnameformat - формат имени переменной для команды !var
<li>varvalue - формат значения переменной в actions, subs.
<li>ansi_format - формат ANSI кодов
<li>float_format - формат вещественных чисел при мат. операциях (результата)
</ul>

<p>Базы данных:
<ul>
<li>db_type - тип сервера баз данных. Если БД нет, то оставьте пустым
<li>db_host - адрес
<li>db_name - имя базы
<li>db_user - пользователь
<li>db_pass - пароль
</ul>

<p>Плагины:
<ul>
<li>dir_plugins - путь к плагинам
<li>[plugins] - секция задания плагинов в формате имя = имя_файла.php
</ul>


<br><br>
<hr>
<a name=run>
<h2>Как запустить?</h2>
Запуск возможен двумя способами:
<ul>
<li>Локально:<br>
Скачайте полный комплект клиента (SMC + настроенный PHP для Win32, с которым он точно будет работать).
Распакуйте все в отдельную директорию, отредактируйте smc.ini и запустите файл smc.bat.
Если при инициализации не произошло никаких ошибок, то появится строка вида "Waiting for connection..."
с адресом и портом на котором клиент ожидает входящие соединения. Прерывается как
любой пакетный файл - Ctrl-Break.
Если вы знакомы с PHP, или у вас не Windows, то можете скачать только скрипт и попытаться его запустить
сами. Скрипт требует PHP 4.1.0 или выше с поддержкой sockets (может будет работать и на более ранних версиях,
не знаю, не проверял). Если кто-то запустит скрипт на других платформах, то напишите мне
пожалуйста инструкцию по запуску, чтобы я смог ее добавить в общий хелп.
<li>Удаленно (у хостера):<br>
Скачайте только скрипт, положите его у вашего хостера, настройте все параметры в smc.ini.
Обязательно удостоверьтесь что ваш хостер поддерживает требуемую версию PHP с sockets extension
(для этого создайте на сервере файл test.php с одной строчкой внутри &lt;? phpinfo(); ?&gt; и
посмотрите его через броузер), и у скрипта есть доступ на запись к файлам.<br>
Запустите http://myhost.hoster.com/smc.php, при этом на экране ничего не появится и
броузер начнет грузить пустую страницу (это означает что все нормально и скрипт работает),
и будет продолжать это делать до бесконечности пока скрипт не завершит работу. Ни в коем случае
не нажимайте в броузере СТОП, это прервет работу клиента. Такая предосторожность сделана специально,
так как если клиент зависнет, то локально вы всегда сможете его прибить, а вот удаленно так
не получится. Поэтому удаленно клиент прибивается нажатием СТОП в броузере.
</ul>
Клиент завершает свою работу в 4 случаях: во время работы произошла фатальная ошибка, пользователь
отключается от клиента, локально - Ctrl-Break, удаленно - СТОП в броузере.


<br><br>
<hr>
<a name=regexp>
<h2>Регулярные выражения</h2>
Все параметры для команд hl, action, trigger, sub, gag, test и др. в SMC являются
<a href="Регулярные выражения (regexp) Часть 1.htm">регулярными выражениями</a>.
SMC (точнее php) поддерживает 2 типа выражений:
<a href="Регулярные выражения Часть 2 POSIX.htm">POSIX</a> и стандарт языка Перл
<a href="Регулярные выражения Часть 3 PCRE.htm">PCRE</a>.<br>
По-умолчанию (устанавливается в smc.ini)
используется POSIX и все форматы настроены для него. Это сделано по одной причине - в PCRE все выражения
должны быть заключены между слэшами: /выражение/, т.е. даже если вы просто захотите подкрасить
слово 'DEAD' красным, то все равно его придется указывать как !hl {/DEAD/} red. Однако PCRE
работают на порядок быстрее и обладают
<a href="Регулярные выражения в PHP (сравнение Perl и PHP).htm">большими возможностями</a>.
Вы сами можете решать что вам
удобнее, только не забудьте поменять все форматы в smc.ini для переменных и ANSI-кодов
если перейдете на PCRE.


<br><br>
<hr>
<a name=db_mysql>
<h2>База данных MySQL</h2>
Если вы полный профан в базах данных, то не пугайтесь громкими названиям типа SQL.
Многие плагины используют MySQL, и работают с ней сами, от Вас лишь требуется поставить ее
на свой компьютер. Она небольшая (около 20 МБ), памяти ест немного (около 5 МБ для NT, 15 для Win9X), поэтому
можете смело ставить. Качайте с <a href="http://www.mysql.org">http://www.mysql.org</a>
последнюю версию, распаковывайте (если в архиве), устанавливайте куда угодно. После
установки (для систем с WinNT, Win2k, WinXP) запустите  c:\mysql\bin\mysqld-nt.exe -install,
идите в настройки служб системы и удостоверьтесь, что служба MySQL грузится автоматически.
Для Win9X/Me вам потребуется в автозагрузку добавить c:\mysql\bin\mysqld.exe.
Перезапустите комп, для SMC в настройках ДБ задайте: тип "mysql", адрес "localhost", база "smc",
пользователь "root", пароля нет. Поздравляю, вы поставили себе SQL сервер!


<br><br>
<hr>
<a name=other_db>
<h2>Другие базы данных</h2>
Текущие поддерживемые БД перечислены в smc.ini. Это означает, что для данных типов SMC попытается
создать базу сам если ее нет, и к ней будет доступ через универсальный класс Db_Sql (из PHPLib) в
переменной $q. Также удостоверьтесь что сам PHP поддерживает этот тип БД (в поддиректории
/php/extensions есть соответствующая dll, и она загружается в php.ini).<br>
Если вы хотите использовать неподдерживаемый тип, то заставьте PHP грузить соответствующую dll,
и затем работайте с базой функциями прямого доступа этой ДБ (смотрите доку по PHP). Если
вы хотите Db_Sql класс для своей базы, то отредактируйте его сами в поддиректории /include/db.
В любом случае не занимайтесь такими вещами если не знаете PHP.


<br><br>
<hr>
<a name=commands>
<h2>Команды</h2>
Можно набирать более одной команды для MUDа сразу, разделяя их знаком <b>#</b>.
Все внутренние команды для SMC должны начинаться со знака <b>!</b>.
После него можно дополнительно указать символ <b>@</b> чтобы
блокировать вывод (полезно в триггерах для избавления от спама).
Если вы хотите использовать другие символы, то задайте их в smc.ini<br>
Команды можно набирать сокращенно по первым буквам, например !tr распознается как !trigger.
Если символ-идентификатор команды отсутствует, то в MUD отсылается то, что вы набрали.
Но помните, что во все, что вы набираете, подставляются значения заданных переменных. Например
если $weapon=mace, то при наборе get $weapon в MUD уйдет команда get mace. Избегайте конфликтов
переменных в SMC и в вашем клиенте. Например JMC использует тот же символ $ для задания
переменных, поэтому если в JMC будет задана переменная $weapon, то до SMC уже дойдет
не get $weapon, а get mace. Всегда помните об этом.<br>
В инструкции рядом с командами будут иногда встречаться комментарии после //. В SMC комментариев
(пока) нету, они приведены здесь только для пояснения.<br>
Формат описания синтаксиса: &lt;param&gt; означает что param должен быть указан, [param] - можно не указывать,
комбинации param1|param2|param3 означает один из перечисленных.
И напоследок немного о прямых слэшах '\'. В php (и C/C++) такой слэш является спецсиволом для задания
управляющих кодов, например перевод строки \n. Поэтому чтобы задать сам слэш как символ, используется
'\\'. В некоторых примерах вы встретите эту комбинацию.<br>
<pre>
Пример (инициализация 3 переменных за раз без вывода):
    !@var $a 1#!@var $b 2#!@var $c $a+$b
Послать в MUD содержимое переменной
    $cmd
</pre>


<br>
<hr>
<a name=cmd_about>
<h2>ABOUT</h2>
<pre>
Синтаксис: !about
</pre>
Информация о SMC: версия, версия PHP, база данных (если есть).


<br>
<hr>
<a name=cmd_connect>
<h2>CONNECT</h2>
<pre>
Синтаксис: !connect &lt;host&gt; &lt;port&gt;
</pre>
Подключение к серверу. Если адрес и порт не указаны, то берется адрес из переменной mud_address в smc.ini
<pre>
    !connect temple.ptt.ru 4000
</pre>


<br>
<hr>
<a name=cmd_zap>
<h2>ZAP</h2>
<pre>
Синтаксис: !zap
</pre>
Прервать текущее соединение с сервером.


<br>
<hr>
<a name=cmd_cr>
<h2>CR</h2>
<pre>
Синтаксис: !cr
</pre>
Посылает перевод строки в MUD.


<br>
<hr>
<a name=cmd_drop>
<h2>DROP</h2>
<pre>
Синтаксис: !drop
</pre>
Удаляет текущую строку из мада. Команда может быть использована в составе action или trigger.
<pre>
Фактически совмещение action + gag. Выведет красным I'm BASHED при срабатывании, а сама строка
из мада будет удалена.
    !action {.+ bashes you!} {!showme {I'm BASHED!} red#!drop}
</pre>


<br>
<hr>
<a name=cmd_textin>
<h2>TEXTIN</h2>
<pre>
Синтаксис: !textin &lt;filename&gt; [prefix]
</pre>
Загружает содержимое файла filename и посылает в мад. Полезно при написании больших текстов.
Если указан параметр prefix, то его содержимое будет добавлено к началу каждой строки.
<pre>
Загрузка своего описания из файла (в начале каждой строки команда маду desc +)
    !textin fighter.txt desc +
</pre>



<br>
<hr>
<a name=cmd_textout>
<h2>TEXTOUT</h2>
<pre>
Синтаксис: !textout &lt;filename&gt; [text]
</pre>
Сохраняет текст text (с добавлением перевода строки) в файл filename. Text может содержать
переменные. Если текст не указан, то сохраняется просто перевод строки.
<pre>
Будем вести небольшой лог с датой и временем когда нас отсуммонили
    !action {$attacker has SUMMONED YOU!} {!@var curdate date('d.m.Y H:i')#!@textout log.txt $curdate $attacker summoned me.}
Скромная замена плагину Items - будем сохранять в файл все встретившиеся вещи + доп. перевод строки
    !trigger {Object .+ is type .+} {!@textout items.txt $reg[0]#!@textout items.txt} block
</pre>



<br>
<hr>
<a name=cmd_commands>
<h2>COMMANDS</h2>
<pre>
Синтаксис: !commands [param]
</pre>
Выводит список всех доступных команд, включая и те, что добавлены плагинами. Если указан
необязательный параметр param, то будут выведены только те команды, которые содержат param.
<pre>
Вывод всех команд
    !commands
Вывод команд содержащих слово tick (плагин ticker)
    !commands tick
</pre>


<br>
<hr>
<a name=cmd_info>
<h2>INFO</h2>
<pre>
Синтаксис: !info
</pre>
Выводит количество заданных алиасов, триггеров и т.д., а также количество загруженных плагинов
и другую информацию.


<br><br>
<hr>
<a name=cmd_savelog>
<h2>SAVELOG</h2>
<pre>
Синтаксис: !savelog &lt;filename&gt; [option1 option2 ...]
</pre>
Вся информация приходящая из MUDа автоматически запоминается. Чтобы скинуть текущий накопленный лог
в файл используйте команду !savelog. filename - имя файла (если без указания пути, то файл будет создан
в той же директории, где и скрипт). filename может содержать параметры текущего времени/даты:<br>
<ul>
<li>%d - день
<li>%m - месяц
<li>%y - год
<li>%h - часы
<li>%i - минуты
</ul>
Также имя файла может быть указано в переменной. Если вместо имени файла указано
ключевое слово 'clear', то лог очищается без сохранения. Если не указано ни одного параметра,
то выполняется операция автосохранения с настройками из smc.ini.
Доступные опции:
<ul>
<li>append - дописать к уже существующему файлу (если его нет, то создать новый файл)
<li>noclear - не очищать лог после сохранения
<li>cr - использовать в качестве разделителя строк символ \n (код 10) (по-умолчанию)
<li>lf - использовать в качестве разделителя строк символ \r (код 13)
<li>crlf - использовать в качестве разделителя строк символы \r\n
<li>ansi - сохранять ansi-коды цветов
<li>html - сохранить лог в формате html (опции append и ansi при этом бессмысленны)
</ul>
<pre>
Сохранить лог в файл fightxxxxxx.log (где xxxxxx - текущая дата)
    !savelog fight%d%m%y.log
Сохранить лог в файл с именем в переменной $logname
    !savelog $logname
Приписать к файлу travel.txt с разделителем \r\n и сохранением ansi-цветов
    !savelog travel.txt append crlf ansi
Сохранить в pk.htm
    !savelog pk.htm html
Очистить лог
    !savelog clear
</pre>


<br>
<hr>
<a name=cmd_simul>
<h2>SIMUL</h2>
<pre>
Синтаксис: !simul &lt;expression | file filename&gt;
</pre>
Позволяет симулировать строку (или файл), как будто она пришла из MUDа. Незаменимая
команда при проверке ваших подсветок, триггеров, гагов и др.
Можно задать параметры 2 видов - строка или ключевое слово file с именем файла после него.
<pre>
Симулировать строку
    !simul Bajoi's bash injures Shapa
Симулировать файл log.txt
    !simul file log.txt
</pre>

<br>
<hr>
<a name=cmd_simulvars>
<h2>SIMULVARS</h2>
<pre>
Синтаксис: !simulvars &lt;expression | file filename&gt;
</pre>
То же, что и simul, но сначала в параметры парсятся переменные.
<pre>
Симулировать строку (переменная $target=Shapa)
    !simul Bajoi's bash injures $target
Симулировать строку целиком из переменной $str
    !simul $str
Симулировать файл (имя файла в переменной $log)
    !simul file $log
</pre>

<br>
<hr>
<a name=cmd_test>
<h2>TEST</h2>
<pre>
Синтаксис: !test &lt;{regexp}&gt; &lt;{text}&gt;
</pre>
Команда проверки регулярных выражений. Ищет регулярное выражение regexp в
строке text. Выводит найденную строку и подвыражения
если есть совпадение. В связке с командой <a href=#cmd_simul>simul</a>
вы можете настроить все ваши параметры (триггера и др.) даже не подключаясь к MUDу.
<pre>
Поиск нападающего
    !test {(^[A-Z][a-z]+)'s strangulation attempt misses you} {Shomberg's strangulation attempt misses you}
Определение мага и жертвы
    !test {([A-Z][a-z]+) yells "Help! ([A-Z][a-z]+) is casting a spell on me!"} {Siorosh yells "Help! Eleum is casting a spell on me!"}
</pre>



<br>
<hr>
<a name=cmd_php>
<h2>PHP</h2>
<pre>
Синтаксис: !php &lt;expression&gt;
</pre>
Команда выполняет заданное выражение expression как php выражение. 
Так как все команды в php разделяются точкой с запятой, в свою
очередь используемую многими MUD-клиентами как разделитель команд, то вы вряд ли сможете исполнить
больше одной команды за раз. Но этого вполне достаточно, чтобы вызвать свои функции (определяемые
в userfunc.php). Помните, что переменные вам напрямую недоступны, и пока вы не ознакомитесь с php
данной командой лучше не пользоваться.
<pre>
Занесение значения в переменную $target
    !php $GLOBALS['vars']['target'] = 'Shapa'
Вызов функции myfunc() с параметром в виде переменной $hp и присвоением результата ей же
    !php $GLOBALS['vars']['hp'] = myfunc($GLOBALS['vars']['hp'])
</pre>


<br>
<hr>
<a name=cmd_show>
<h2>SHOW</h2>
<pre>
Синтаксис: !show &lt;expression&gt;
</pre>
Выводит заданное выражение, которое может включать и переменные. Если в выражении
присутствует хотя бы одна переменная, то оно выполняется как
php команда, поэтому для работы со строками следует применять правила php (строки заключаются в
одиночные или двойные кавычки, для сложения строк используется точка).
Помните, что это команда системного вывода, и на выведенные строки не будут работать
ваши замены, триггера и др. (а также при выводе будет добавлен префикс, заданный в smc.ini).
Чтобы они работали, воспользуйтесь командой <a href=#cmd_simul>simul</a>.
<pre>
Вывод строки
    !show Hello world!
Вывод переменной
    !show $maxhp
Вывод математического выражения
    !show $hp/$maxhp*100
    !show "Current hp percentage is ".($hp/$maxhp*100)."%"
Вывод строки с переменной
    !show "My enemy is $target"
    !show "My enemy is ".$target
</pre>


<br>
<hr>
<a name=cmd_showme>
<h2>SHOWME</h2>
<pre>
Синтаксис: !showme &lt;{expression}&gt; &lt;color&gt;
</pre>
Аналогично команде show, но в дополнение можно указать цвет (цвета смотрите командой colors).
Если выражение для вывода содержит более 1 слова (т.е. содержит пробелы),
то заключите его в {}. Это не системный вывод, поэтому префикс (если есть) не добавляется.
<pre>
Вывод строки желтым
    !showme {Hello world!} yellow
Вывод переменной красным
    !showme $maxhp red
</pre>


<br>
<hr>
<a name=cmd_quite>
<h2>QUITE</h2>
<pre>
Синтаксис: !quite [on|off]
</pre>
Включает/выключает режим блокирования вывода. При этом вы будете видеть только текст приходящий
от MUDа. Если команда указана без параметров, то происходит смена режима, иначе можно задать состояние
вручную (on - включено, off - выключено)
<pre>
Переключить режим
    !quite
Выключить
    !quite off
</pre>


<br>
<hr>
<a name=cmd_ignore>
<h2>IGNORE</h2>
<pre>
Синтаксис: !ignore [type] [on|off]
</pre>
Задает режим отключения триггеров, акшинов, гагов и т.д. Если type не указан, то изменит состояние
всех команд. При отсутствии on/off текущее состояние инвертируется.
Допустимые параметры для type: actions, triggers, subs, gags, hls
<pre>
Выключить все
    !ignore on
Отключить замены
    !ignore subs on
Переключить состояние для триггеров
    !ignore triggers
</pre>


<br><br>
<hr>
<a name=cmd_null>
<h2>NULL</h2>
<pre>
Синтаксис: !null
</pre>
Пустая команда (ничего не делать). Некоторые команды требуют наличия определенного количества
параметров, и там где действие не требуется можно указать null.
<pre>
Action будет инициализировать переменные, но ничего не делать
    !action {$looser falls flat on his face} {!null}
</pre>


<br>
<hr>
<a name=cmd_load>
<h2>LOAD</h2>
<pre>
Синтаксис: !load [name]
</pre>
Загрузить профайл name и сделать его текущим (т.е. при выходе все изменения будут сохранены в него).
Если имя не указано, то выводит список всех профайлов в той же директории, где и скрипт.
Профайл имеет расширение, указанное в smc.ini (по-умолчанию cmd).
<pre>
Вывести профайлы
    !load
Загрузить профайл newbie
    !load newbie
</pre>


<br>
<hr>
<a name=cmd_clear>
<h2>CLEAR</h2>
<pre>
Синтаксис: !clear &lt;param&gt;
</pre>
Очистить указанный набор. Param может принимать значения vars, aliases, hls, actions, triggers, subs,
gags и all для очистки всего.
<pre>
Удалить все переменные
    !clear vars
Удалить все
    !clear all
</pre>


<br>
<hr>
<a name=cmd_colors>
<h2>COLORS</h2>
<pre>
Синтаксис: !colors
</pre>
Выводит все цвета с их именем (которое надо указывать в команде <a href=#cmd_hl>hl</a>). Default
цвет задается в smc.ini и определяет цвет после раскраски и вывода сообщений SMC.
<pre>
Показать все цвета
    !colors
</pre>


<br>
<hr>
<a name=cmd_loop>
<h2>LOOP</h2>
<pre>
Синтаксис: !loop &lt;from&gt; &lt;to&gt; &lt;expression&gt;
           !loop &lt;array variable&gt; &lt;expression&gt;
</pre>
Выполнение заданного выражения expression в цикле. Цикл может быть индексированным,
в этом случае указываются 2 числа от (from) и до (to), текущий индекс цикла доступен
через временную переменную %0. Если вместо чисел указано имя переменной-массива, то
цикл идет по всем элементам массива, при этом индекс массива будет в %0, а значение в %1.
<pre>
Взять bread из 1,2 и 3-ей сумки
    !loop 1 3 get bread %0.bag
Вывод найденных подстрок после поиска регулярного выражения
    !loop $reg !show reg[%0] = %1
</pre>


<br>
<hr>
<a name=cmd_N>
<h2>N - число</h2>
<pre>
Синтаксис: !N &lt;expression&gt;
</pre>
Выполнение заданного выражения expression N раз. Если expression содержить несколько команд, то
заключите их в {}.
<pre>
Посакрифаить 5 вещей
    !5 sacr 1.
Купить 10 буханок и положить их в сумку
    !10 {buy bread#put bread bag}
В данном примере 10 раз выполнится buy bread и после этого 1 раз put bread bag
    !10 buy bread#put bread bag
</pre>


<br>
<hr>
<a name=cmd_sql>
<h2>SQL</h2>
<pre>
Синтаксис: !sql &lt;sql statement&gt;
</pre>
Выполняет sql запрос к текущей подключенной базе данных. Для SELECT выводит найденные записи и их
количество, для UPDATE, INSERT, DELETE количество измененный записей.
При выборке SELECT выводятся все записи и все поля, что может потребовать определенное время и затраты
памяти, поэтому не рекомендуется например делать select * from xxx из таблицы с 10000 записей.
<pre>
Выводит список всех баз (для MySQL)
    !sql show databases
Удаление
    !sql delete from items where id&gt;100 and id&lt;200
</pre>



<!-- =============================== GAMEPLAY COMMANDS ================================= -->

<br>
<hr>
<a name=cmd_var>
<h2>VAR</h2>
<pre>
Синтаксис: !var &lt;name&gt; [value]
</pre>
Задание и вычисление переменных. name - имя переменной или ее номер (по команде vars). value - значение
переменной (php выражение). Если value не указано, то переменная удаляется. Выражение вычисляется на
момент присвоения переменной, т.е. если вы укажете !var $a $b+$c, то в $a будет занесена сумма
текущих на ДАННЫЙ момент значений переменных $b и $c.<br>
В php тип переменной определяется в момент ее использования, поэтому правильно применяйте
различные операторы. Допустим, что $a=1 и $b=2. Мат. выражение $a+$b=3, а строковое $a.$b=12.
Если строка содержит одно слово, то кавычки можно не писать.
Переменная также может являться многомерным массивом, в качестве ключей желательно использовать
слова а не цифры (если одно слово, то кавычки также можно не писать). Сама строка является
массивом символов, поэтому любой символ можно адресовать по индексу начиная с 0.
Примечание: так как name всегда содержит имя переменной, то символ $ можно не указывать.<br>
<font color=red>
Внимание: В текущей версии SMC вылетит если вы попытатесь обратиться к несуществующей функции
(это ограничение PHP, я стараюсь найти решение этой проблемы). Поэтому сомнительные конструкции
старайтесь настраивать не подключаясь к маду.
</font>
<pre>
Задать переменную
    !var $target Sebant
    !var $hours 5
    !var $sum 1+2+3
Удалить переменную $var1
    !var $var1
Ссылка по номеру (удалить переменную номер 1)
    !var 1
Задать переменную номер 3 если она существует (=4)
    !var 3 "2"+2
Математическое выражение
    !var $lefthp $maxhp-$hp
    !var $super_puper_math tan(max(($a1*$a2)/sqrt(4), 100)*exp(log($b))/cos($b1))
    !var $random mt_rand(1, 100) // случайное число от 1 до 100
Строковое выражение
    !var $longstr "This is a long string"
    !var $killcommand "c sleep ".$target
Взять 5-й символ строки из переменной $str (занести обратно также НЕЛЬЗЯ! (todo))
    !var $char5 $str[5]
Занесение пустоты (пустой строки)
    !var $target ""
Задание массива
    !var $damages[scratches][min] 1
    !var $damages[scratches][max] 2
    !var $damages[grazes][min] 3
    !var $damages[grazes][max] 5
теперь массивами являются как $damages, так и $damages[scratches] и $damages[grazes].
!show $damages выведет Array
Вычисление $graze = 2
    !var $graze $damages[grazes][max] - $damages[grazes][min]
Использование операторов и функций (описание смотрите в интернете, например www.php.net)
    !var $condition $hp>500?"good":"bad"
    !var $condition $hp>500?"good":($hp>300?"bad":"awful")
    !var $uppercasedsong strtoupper($songname)
    !var $firstchar substr($target, 0, 1)
    !var $str_without_leading_spaces ltrim($target)
    !var $substring_position strpos($string, $substring)
</pre>


<br>
<hr>
<a name=cmd_vars>
<h2>VARS</h2>
<pre>
Синтаксис: !vars [param]
</pre>
Вывод всех переменных с их номером.
Если указан необязательный параметр param, то будут выведены только те переменные,
которые содержат param в своем имени.
<pre>
Все переменные
    !vars
Переменные содержащие в имени tar
    !vars tar
Просмотр найденных подвыражений (массив $reg)
    !vars reg[
</pre>


<br>
<hr>
<a name=cmd_alias>
<h2>ALIAS</h2>
<pre>
Синтаксис: !alias &lt;name&gt; [{value}]
</pre>
Задание алиасов, т.е. при наборе имени алиаса в MUD посылается его значение как будто
вы набрали его сами.
name - имя алиаса, value - его значение (в фигурных скобках), может также содержать
в себе другие алиасы (но не сам себя!). В отличие от
других объектов, к алиасам нельзя обратиться по номеру, чтобы можно было задавать алиасы на сами
цифры. Если задается несколько команд, то разделяйте их символом #. Если параметр value пуст,
то алиас удаляется.
Если при использовании алиаса вместе с ним в одной строке были дополнительно указаны
какие-либо параметры, то они будут доступны через временные переменные %1-%9
(%0 - вся строка параметров целиком).
<pre>
Задание алисов
    !alias dis {get sword#wear sword}
    !alias 1 {strangle $enemy}
    !alias ppp {!show "Current path is $path"}
С параметрами
    !alias v {!@var %0}  // теперь можете задавать переменные как v a 1 ($a=1)
Команда x siorosh выдаст 2 команды: c summon siorosh и c sleep siorosh
    !alias x {c summon %0#c sleep %0}
Действие через переменную (бессмысленно, ради примера)
    !alias x {!@var $killcommand "bash ".$target#$killcommand}
Алиас возврата на 1 шаг назад. Предположим, что накопленный путь хранится в переменной $path.
Необходимо задать массив обратных путей:
    !var ret[w] e#!var ret[e] w#!var ret[s] n#!var ret[n] s#!var ret[u] d#!var ret[d] u
    !alias return {!@var $laststep substr($path, -1)#!@var $path substr($path, 0, strlen($path)-1)#$ret[$laststep]#!show "Now the path is $path"}
</pre>


<br>
<hr>
<a name=cmd_aliases>
<h2>ALIASES</h2>
<pre>
Синтаксис: !aliases [param]
</pre>
Вывод списка всех заданных алиасов. 
Если указан необязательный параметр param, то будут выведены только те алиасы,
которые содержат param в своем имени.
<pre>
</pre>


<br>
<hr>
<a name=cmd_hl>
<h2>HL</h2>
<pre>
Синтаксис: !hl &lt;{regexp}&gt; &lt;color1&gt; [color2]
</pre>
Определение подстветок (highlights). regexp - регулярное выражение, которое надо
подкрасить, color1 - цвет, который будет установлен в начале найденной строки,
color2 - цвет в конце строки (если не указан, то используется default цвет).
Список всех цветов можно посмотреть по команде <a href=#cmd_colors>colors</a>.
Благодаря указанию 2 цветов, можно подкрашивать многострочные выражения.
Можете сначала потестировать ваши регулярные выражения командой <a href=#cmd_test>test</a>.
<pre>
Красить все слова bashes красным
    !hl {bashes} red
Красить упавший санк голубым
    !hl {The white aura around your body fades} cyan
Подкрашивать строки нахождения чуваков под санком белым (символ '(' является служебным
в синтаксисе регулярных выражений, поэтому дополняем его слэшами)
    !hl {\\(White aura\\) .+ is .+ here} white
Красить весь последующий текст после указанной строки серым (кроме самой строки),
и закончить раскраску на другой строке (включая ее).
    !hl {^[A-Z][a-z]+ is using} default gray
    !hl {&lt;wielded&gt;    } gray default
</pre>


<br>
<hr>
<a name=cmd_hls>
<h2>HLS</h2>
<pre>
Синтаксис: !hls
</pre>
Вывод всех подсветок с их номерами.


<br><br>
<hr>
<a name=cmd_trigger>
<h2>TRIGGER</h2>
<pre>
Синтаксис: !trigger &lt;{regexp}&gt; &lt;{commands}&gt; [block]
</pre>
Выполняет поиск регулярного выражения regexp в каждой строке, пришедшей из MUDа, и в случае
совпадения выполняет команды commands. Вместо параметра regexp можно использовать номер
триггера для его редактирования. regexp не должен содержать никаких переменных (в отличие
от actions), вместо это все найденные подвыражения автоматически помещаются в массив $reg с
номером в порядке появления ($reg[0] - вся найденная строка).<br> 
Если вы задали триггер на строку состояния, то пометьте
его как prompt командой <a href=#cmd_prompt>prompt</a>.<br>
Если указан параметр block, то триггер будет вызываться на текст между строками состояния,
т.е. при срабатывании prompt. Это позволяет выполнять многострочные проверки.
Можете сначала потестировать ваши регулярные выражения командой <a href=#cmd_test>test</a>.
<pre>
Простейшие триггера
    !trigger {You are hungry} {c 'create food'#get mushroom#eat mushroom}
    !trigger {You are thirsty} {get $water $bag#drink $water#put $water $bag}
Регулярные выражения
    !trigger {([A-Za-z])'s bash .+ you} {!@var $basher $reg[1]}
Триггер на строку состояния вида &lt;10/100hp 20/200mana 40mv tnl:123456 Exits:EWN&gt;
Найденные подвыражения заносятся в соотв. переменные
    !trigger {&lt;([0-9]+)/([0-9]+)hp ([0-9]+)/([0-9]+)mana ([0-9]+)mv tnl:([0-9]+) Exits:(.+)&gt;} {!@var $hp $reg[1]#!@var $maxhp $reg[2]#!@var $mana $reg[3]#!@var $maxmana $reg[4]#!@var $moves $reg[5]#!@var $tnl $reg[6]#!@var $exits $reg[7]}
Многострочный триггер: определение клерика Majere и его занесение в базу whois (плагин whois)
    !trigger {([A-Z][a-z]+) is using:.+ a sign of the clenched Fist} {!@whois $reg[1] cleric of Majere} block

</pre>

<br>
<hr>
<a name=cmd_triggers>
<h2>TRIGGERS</h2>
<pre>
Синтаксис: !triggers [param]
</pre>
Вывод всех триггеров с их номерами (содержащих param).



<br><br>
<hr>
<a name=cmd_action>
<h2>ACTION</h2>
<pre>
Синтаксис: !action &lt;{regexp}&gt; &lt;{commands}&gt;
</pre>
Выполняет поиск регулярного выражения regexp в каждой строке, пришедшей из MUDа, и в случае
совпадения выполняет команды commands. Вместо параметра regexp можно использовать номер
action'а для его редактирования. regexp может содержать переменные (в отличие
от triggers), которые автоматически будут заполняться найденными выражениями. Формат
значения переменной при поиске задается в smc.ini и по-умолчанию равен ".+" (т.е.
строка длиной не менее 1, содержащая любые символы). Actions можно рассматривать как более
простую и удобную версию триггеров, но с гораздо меньшими возможностями. Если вы хорошо
владеете регулярными выражениями, то actions вам не нужны. С помощью триггеров принципиально
можно распарсить любую строку, actions такого делать не позволяют, но зато автоматически
инициализируют переменные, поэтому не надо писать например !@var $hp $reg[1].<br>
Если вы задали action на строку состояния, то пометьте
его как prompt командой <a href=#cmd_prompt>prompt</a>.<br>
Можете сначала потестировать ваши регулярные выражения командой <a href=#cmd_test>test</a>.
<pre>
Простейшие примеры
    !action {You are hungry} {eat $food} // $food задается заранее
    !action {$basher's bash .+ you} {!null} // в $basher занесется имя вашего обидчика
    !action {$someone leaves $direction\\.} {!show "$someone -> $direction"}
Action на строку состояния вида &lt;10/100hp 20/200mana 40mv tnl:123456 Exits:EWN&gt;
задать нельзя, так как например в $maxhp будет занесено не "100", a "100hp". Но если отделить
цифры от букв, то возможно: &lt;10/100 hp 20/200 mana 40 mv&gt; (и вычислим проценты)
    !action {&lt;$hp/$maxhp hp $mana/$maxmana mana $moves mv&gt;} {!@var $hpp $hp/$maxhp*100#!@var $mnp $mana/$maxmana*100}
</pre>


<br>
<hr>
<a name=cmd_actions>
<h2>ACTIONS</h2>
<pre>
Синтаксис: !actions [param]
</pre>
Вывод всех actions с их номерами (содержащих param).


<br><br>
<hr>
<a name=cmd_prompt>
<h2>PROMPT</h2>
<pre>
Синтаксис: !prompt [action|trigger] [N]
</pre>
Указывает SMC что заданный триггер или action номер N является строкой приглашения. При изменении
номеров в триггерах/акшинах заданный номер N не отслеживается, так что задайте заново.
Часть функций SMC и ряд плагинов напрямую зависят от наличия prompt, поэтому как можно быстрее
определите его. Если команда вызвана без параметров, то выводит текущий заданный prompt.
<pre>
Вывести текущий prompt
    !prompt
Указать что триггер номер 8 является строкой приглашения
    !prompt trigger 8
Указать что action номер 1 является строкой приглашения
    !prompt action 1
</pre>

<br>
<hr>
<a name=cmd_sub>
<h2>SUB</h2>
<pre>
Синтаксис: !sub &lt;{regexp}&gt; &lt;{value}&gt; [later]
</pre>
Задает подстановки. В каждой строке, пришедшей из MUD, ищется регулярное выражение
regexp, и если подстрока найдена, то она заменяется на value. Вместо regexp может
использоваться номер. regexp также, как и у actions, может содержать переменные, в которые
будут занесены найденные подвыражения. Если value пуст, то совпавшая строка полностью
удаляется (по сути тот же <a href=#cmd_gag>gag</a>). По-умолчанию подстановки
выполняются до триггеров и actions. Чтобы выполнить подстановку после них, укажите параметр
later.

<pre>
Заменять все слова fuck на ****
    !sub {fuck} {****}
Убрать спам от мобов
    !sub {A merman guard says 'State your business .+, or be gone!'} {} 
Убрать с экрана все отпарированные, уклоненные и т.д. удары по вам
    !sub {^You (parry|dodge|hand block|shield block).+} {}
... а теперь ваши промахи
    !sub {^[A-Z][a-z]+ (parries|dodges|hand blocks|shield blocks) your .+} {}
С переменными
    !sub {$enemy's kick dirt .+ you} {$enemy DIRTED ME!}
Использование later (вывести новую строку состояния в процентах, см. пример в action)
    !sub {&lt;.+Exits:.+&gt;} {&lt;$hp/$hpp% $mana/$manap% $moves Tnl:$tnl Exits:$exits&gt;} later
</pre>


<br>
<hr>
<a name=cmd_subs>
<h2>SUBS</h2>
<pre>
Синтаксис: !subs [param]
</pre>
Вывод всех замен с их номерами (содержащих param).


<br><br>
<hr>
<a name=cmd_gag>
<h2>GAG</h2>
<pre>
Синтаксис: !gag &lt;{regexp}&gt; &lt;mode1&gt; [mode2]
</pre>
Определение блокированных строк (спрятанных). regexp - регулярное выражение, которое надо
спрятать. Оно может содержать переменные, которые будут вставлены в него в момент проверки
(не путать с <a href=#cmd_sub>sub</a> - там переменные берутся из найденной строки,
здесь вставляются в поисковую строку).<br>
mode1 - режим сокрытия, который будет установлен в начале строки (не найденной, а всей),<br>
mode2 - режим сокрытия в конце строки (если не указан, то vis).<br>
Существует 2 режима - vis (видимый) и hidden (невидимый).
Благодаря указанию 2 режимов можно скрывать многострочные выражения.<br>
При выполнении многострочных блокировок вы можете включить блокирование, но, например, из-за
ошибки в регулярном выражении для его выключения он не отключится, и таким образом вы больше
на экране ничего не увидите. Воизбежание таких случаев блокировка автоматически выключается
при появлении статусной строки (prompt). Если вы не подключены к серверу и настраиваете
гаги в автономном режиме, то можете принудительно отключить блокировку, задав вместо regexp
ключевое слово off. Активность блокировки можно проверить командой <a href=#cmd_simul>simul</a>
(она просто ничего не будет выдавать).
<pre>
Убрать с экрана все отпарированные, уклоненные и т.д. удары по вам
    !gag {^You (parry|dodge|hand block|shield block).+} hidden
Спрятать причитания вашей жертвы (с именем в переменной $victim)
    !gag {^$victim tells you} hidden
Многострочные блокировки: скрыть тексты всех песен (в Solace MUD)
    !gag {the deep words of} vis hidden
    !gag {^ [A-Z].+'$( )?} hidden vis
Выключить блокировку
    !gag off
</pre>


<br>
<hr>
<a name=cmd_gags>
<h2>GAGS</h2>
<pre>
Синтаксис: !gags [param]
</pre>
Вывод всех скрываемых строк с их номерами (содержащих param).


<br><br>
<hr>
<a name=userfuncs>
<h2>Функции пользователя</h2>
Учите PHP, и пишите свои функции в файле userfunc.php. Сам SMC представляет собой открытый исходник, так
что смотрите сами как все работает, какие функции доступны и т.д. Пример вызова своих функций есть в
примерах команды <a href=#cmd_php>php</a>.


</body>
</html>