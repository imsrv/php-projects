<!-- Нажмите Alt+F4 -->
<html><head>
<title>Регулярные выражения (regexp). Часть первая -- Техника программирования -- версия для печати -- php в деталях</title>
<meta name="keywords" content="программирование php programming пхп php4 php3 zend html базы данных mysql php+mysql apache апач апаче phpmyadmin скрипт script array массив object объект объектно-ориентированное программирование ООП бесплатно free open source открытый источник код безопасность security">
<meta name="description" content="Детальное описание приёмов программирования PHP, примеры, бесплатные скрипты">

<link rel=stylesheet type=text/css href=/pict/all.css>
</head>
<body link=#0063a5 alink=#0063a5 vlink=#004385 bgcolor=#ffffff>
<h2>Полная версия выпуска: <a href=http://detail.phpclub.net/technique/01-02-06/>http://detail.phpclub.net/technique/01-02-06/</a></h2>
<h1>Регулярные выражения (regexp). Часть первая</h1>
<div class="info">DL<br>6.02.2001</div>
<p>Обещал написать про регулярные выражения. Писал, писал, но что-то не то выходит. Слишком мелкая конкретика, пересказывание <a href=http://www.php.net/manual/>руководства по php</a> [1]. Поэтому я решил, что необходимо <i>(приняв степенную осанку)</i> подготовить аудиторию, так сказать, начать с малого... (" - Дорогой, а где моя мама? - Теща уже на крыше.")<br />
<br />
Начну с того, что php поддерживает два стандарта регулярных выражений: <a href=http://www.php.net/manual/ref.regex.php>POSIX</a> [2] и, начиная с четвертой версии, <a href=http://www.php.net/manual/ref.pcre.php>совместимые с Perl</a> [3]. Первый стандарт используется и сервером Apache в mod_rewrite (см. <a href=http://detail.phpclub.net/technique/01-01-15>предыдущий выпуск</a> [4]) а так же... MySQL в своих запросах (поищите слово "REGEXP" в руководстве по mysql, может сразу поймете, а я об этом позже расскажу). Второй, как ясно из названия, используется в системе perl. Два этих стандарта различаются несильно - во втором есть специальные символы, заменяющие наиболее часто используемые классы символов (например, цифры - d, а буквы и цифры - w) и специальные параметры шаблонов, позволяющие определять регистрозависимость поиска, привязку к концам строк и т.д (в функциях стандарта POSIX регистрозависимость реализована просто: есть функции ereg и ereg_eeplace, есть eregi (insensitive) и eregi_replace). В остальном же оба стандарта совместимы, а приемы написания шаблонов одинаковые.<br />
<br />
Если вы работали с Norton/Volkov/Windows Commander или Far, то знаете такую вещь как wildcards. Например: delete c:windows*.* удаляет все файлы из указанной директории. :) В именах файлов особых изощрений делать не приходится, поэтому система простая: символ * означает любой набор символов, в том числе пустой (*.txt), символ ? - любой символ или никакого символа (document?.txt) и еще какие-то обозначения для букв и цифр (я, честно говоря, ими давно не пользовался, поэтому так не вспомню).<br />
<br />
В регулярных выражениях подход иной. Система в первую очередь универсальна и должна уметь находить соответствия строк любым самым сложным запросам (странно, что я говорю "должна уметь", система ведь уже "умеет". Надеюсь читатель простит мне такие фразы, ведь они все относятся к уже работающей системе регулярных выражений.) Сейчас я назову термины, которые буду употреблять в дальнейшем, чтобы избежать растяжимых (в прямом и переносном смысле) определений.<br />
<br />
Итак, задача системы - помимо четко заданных символов ("Вася(.*)Пупкин") позволить указать пользователю поиск заданного количества заданных символов. В приведенном примере с Васей Пупкиным между словами задано любое количество любых символов. Если надо найти шесть цифр, то пишем "[0-9]{6}" (если, например, от шести до восьми цифр, тогда "[0-9]{6,8}"). К чему это все? К тому, что в отличие от wildcard из операционной системы, здесь разделены такие вещи как указатель набора символов и указатель необходимого количества:<br />
<br />
&lt;набор символов&gt;&lt;квантификатор&gt;<br />
<br />
Вместо набора символов может быть использовано обозначение любого символа - точка, может быть указан конкретный набор символов (поддерживаются последовательности - упоминавшиеся "0-9"). Может быть указано "кроме данного набора символов".<br />
<br />
Указатель количества символов в официальной документации по php называется "квантификатор". Термин удобный и не несет в себе кривотолков. Итак, квантификатор может иметь как конкретное значение - либо одно фиксированное ("{6}"), либо как числовой промежуток ("{6,8}"), так и абстрактное "любое число, в т.ч. 0" ("*"), "любое натуральное число" - от 1 до бесконечности ("+": "document[0-9]+.txt"), "либо 0, либо 1" ("?"). По умолчанию квантификатор для данного набора символов равен единице ("document[0-9].txt").<br />
<br />
Разумеется, для более гибкого поиска сочетаний эти связки "набор символов - квантификатор" можно объединять в метаструктуры.<br />
<br />
Как всякий гибкий инструмент, регулярные выражения гибки, но не абсолютно: зона их применения ограничена. Например, если вам надо заменить в тексте одну фиксированную строку на другую, фиксированную опять же, пользуйтесь str_replace. Разработчики php слезно умоляют не пользоваться ради этого сложными функциями ereg_replace или preg_replace, ведь при их вызове происходит процесс интерпретации строки, а это серьезно потребляет ресурсы системы. К сожалению, это любимые грабли начинающих php-программистов (даже я сам, волею судьбы, сперва увидел в руководстве функцию ereg_replace, а только потом, позже, str_replace).<br />
<br />
Пользуйтесь функциями регулярных выражений только если вы не знаете точно, какая "там" строка. Из примеров: <a href=http://detail.phpclub.net/download/search.txt>поисковый код этого сайта</a> [5], в котором из строки поиска вырезаются служебные символы и короткие слова а так же вырезаются лишние пробелы (вернее, все пробелы сжимаются: " +" заменяется на один пробел). При помощи этих функций я проверяю email пользователя, оставляющего свой отзыв. Много полезного можно сделать, но важно иметь в виду: регулярные выражения не всесильны. Например, сложную замену в большом тексте ими лучше не делать. Ведь, к примеру, комбинация "(.*)" в программном плане означает перебор всех символов текста. А если шаблон не привязан к началу или концу строки, то и сам шаблон "двигается" программой через весь текст, и получается двойной перебор, вернее перебор в квадрате. Нетрудно догадаться, что еще одна комбинация "(.*)" означает перебор в кубе, и так далее. Возведите в третью степень, скажем, 5 килобайт текста. Получается 125 000 000 000 (прописью: сто двадцать пять миллиардов операций). Конечно же, если подходить строго, там стольких операций не будет, а будет раза в четыре-восемь меньше, но важен сам порядок цифр.<br />
<br />
Итак, принципы, достоинства и недостатки описаны, теперь надо переходить к конкретике. Два (возможно, сразу следующих) выпуска будут посвящены двум стандартам регулярных выражений - POSIX и PCRE.<br><h2>Ссылки, использованные в выпуске:</h2>1) http://www.php.net/manual/<br>2) http://www.php.net/manual/ref.regex.php<br>3) http://www.php.net/manual/ref.pcre.php<br>4) http://detail.phpclub.net/technique/01-01-15<br>5) http://detail.phpclub.net/download/search.txt</p>

<br><br><h2>Полная версия выпуска: <a href=http://detail.phpclub.net/technique/01-02-06/>http://detail.phpclub.net/technique/01-02-06/</a></h2>
<hr>
&copy; Дмитрий Лебедев &lt;<a href=mailto:dnl@au.ru>dnl@au.ru</a>&gt;<br>
&copy; Клуб PHP-разработчиков &lt;<a href=http://phpclub.net>http://phpclub.net</a>&gt;
</body></html>