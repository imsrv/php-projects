<html>
<head>
<title>Tutorial (для Solace MUD)</title>
</head>
<body>

<h1>Tutorial (для Solace MUD)</h1>


<h1>Пишем роллер</h1>

С чего начинается MUD? Конечно с роллера! Итак, нам нужно написать роллер, причем
сделаем так, чтобы он не только проверял сумму на заданный минимум, но также и каждый
коэффициент. При роллинге Solace выдает нам строку вида:
<pre>
	Str: 13 Int: 20 Wis: 17 Dex: 17 Con: 15 Accept these? (Y/N)
</pre>
Можно написать на нее триггер, но в данном случае она будет легко парситься с помощью action,
да и выглядеть будет менее громоздко.
Наш action будет примерно таким:<br>
<pre>
	!action {Str: $r_str Int: $r_int Wis: $r_wis Dex: $r_dex Con: $r_con Accept these} {!null}
</pre>
Возникает вопрос - а где окончание строки "? (Y/N)". И тут же ответ - а оно нам нужно?
И знак вопроса, и скобки являются метасиволами в регулярных выражениях, придется ставить перед
ними два слэша \\, а наш action и так будет срабатывать. Второй вопрос - зачем !null?
Ответ - просто сначала сделаем так, чтобы он ничего не делал, кроме парсинга переменных. Кстати,
все переменные начинаются с "r_", это сделано специально чтобы можно было их все сразу
просмотреть командой
<pre>
	!vars r_
</pre>
Предположим, что минимальные значения требуемых коэффициентов будут задаваться в переменных
$r_minstr, $r_minint и т.д., а требуемая сумма в $r_minsum. Давайте напишем подстановку,
чтобы сразу все видеть:
<pre>
	!sub {Str.+Accept these.+} {Str:$r_str($r_minstr) Int:$r_int($r_minint) Wis:$r_wis($r_minwis) Dex:$r_dex($r_mindex) SUM:$r_sum($r_minsum)} later
Получим:
	Str:16() Int:18() Wis:16() Dex:12() Con:18() SUM:()
</pre>
Вопрос - почему именно {Str.+Accept these.+}? Ответ - подстановки заменяют найденную подстроку, поэтому чтобы
полность заменять строку коэф-тов добавим к "Accept these" ".+" (точка означает любой символ, плюс - один или более раз) с
обеих сторон. Тогда зачем Str в начале? Да на всякий случай, вдруг где-то в MUD вам попадется текст с
подстрокой "Accept these". Параметр later указан, чтобы подстановка работала после нашего action'а, так как
мы выводим переменные, которые инициализирует action.<br>
Пока все просто, теперь приступаем к рассчетам.<br>
Для начала вычислим сумму всех коэффициентов. Напишите команду !actions и посмотрите номер нашего ранее
заданного action'а. Предположим, что у него номер 1.
<pre>
	!action 1 {!@var r_sum $r_str+$r_int+$r_wis+$r_dex+$r_con}
</pre>
В переменной $r_sum теперь хранится сумма. Надо ее проверить с требуемым минимумом.
В языке C (и в PHP) есть замечательный оператор вида переменная = условие?верно:неверно.
То есть в переменную будет занесено верно, если условие выполняется, и неверно в обратном
случае. После всех наших вычислений мы должны отослать в MUD y или n. Заведем переменную,
которая как раз будет хранить данную команду после всех рассчетов, назовем ее $y.
Итак:
<pre>
	!@var y $r_sum>=$r_minsum?y:n	
</pre>
Вроде элементарно? Занести в $y символ y если полученная сумма больше или равна минимальной
сумме, и n в противном случае. Теперь надо проделать то же самое со всеми коэффициентами,
за одним исключением: делать дальнейшие сравнения только если $y=y, и это я думаю понятно
без объяснений. Используем вложенный оператор:
<pre>
	!@var y $y==n?n:($r_str>=$r_minstr?y:n)
</pre>
Если $y уже содержит n, то n и оставить, иначе сравниваем далее. Я надеюсь, что вы хоть чуть
чуть знакомы c языком С, и поэтому для вас это должно быть элементарно. Единственное
преимущество php, которое мы используем здесь, наверно вас уже немного смутило - почему
все сиволы y и n указаны без кавычек, как в С? Ответ прост - php подразумевает, что если
указанный параметр состоит из одного слова (или символа), то это строка. Очень удобно.
Проводим похожие сравнения со всеми переменными. В итоге нам надо выдать содержимое
переменной $y в MUD, чтобы это сделать просто дайте команду $y (значения переменных
подставляются во все, что отправляется в MUD автоматически). Итоговый action:
<pre>
	!action {Str: $r_str Int: $r_int Wis: $r_wis Dex: $r_dex Con: $r_con Accept these?} {!@var r_sum $r_str+$r_int+$r_wis+$r_dex+$r_con#!@var y $r_sum>=$r_minsum?y:n#!@var y $y==n?n:($r_str>=$r_minstr?y:n)#!@var y $y==n?n:($r_int>=$r_minint?y:n)#!@var y $y==n?n:($r_wis>=$r_minwis?y:n)#!@var y $y==n?n:($r_dex>=$r_mindex?y:n)#!@var y $y==n?n:($r_con>=$r_mincon?y:n)#$y}
</pre>
Вот и все! Выглядит громоздко, но на самом деле это просто повторения одного и того же.
Как только выполнятся все условия, MUD получит символ y. Чего и добивались :)
Если вы не хотите, чтобы посылался y, а просто чтобы все замерло, до вместо последней команды
$y поставьте
<pre>
	!php if ($GLOBALS[vars][y]==n) mud_writeln(n)
</pre>
Объяснять не буду, учите php сами.<br>
Итак, как пользоваться? Задаете минимальную требуемую сумму, затем минимальные значения
коэффициентов (если какие либо коэф-ты не заданы, то они просто не будут учитываться, так
как при сравнении >= любая цифра будет больше пустоты). Например:
<pre>
	!var r_minsum 95
	!var r_minwis 18
	!var r_minint 20
	!var r_mindex 18
	!var r_mincon 19
</pre>

P.S. Чтобы выключить работающий роллер, используйте команду !ignore.


<h1>Настраиваем prompt</h1>

Вы удачно сроллили себе героя, теперь первым делом надо настроить prompt.
Хотите видет процентные отношения вашего здоровья или маны?  Сейчас сделаем.
Первым делом надо настроить prompt в самом MUD. Допустим, это будет
<pre>
prompt &lt;%h/%Hhp %m/%Mmn %vmv Tnl:%X Exits:%e&gt;
</pre>
Так как максимальные значения здоровья и маны сливаются с символами hp и mn, то action в данном случае
нам не помошник. Пишем триггер, заключая каждое подвыражение в скобки:
<pre>
	!trigger {&lt;([0-9]+)/([0-9]+)hp ([0-9]+)/([0-9]+)mn ([0-9]+)mv Tnl:([0-9]+) Exits:(.+)&gt;} {!@var hp $reg[1]#!@var maxhp $re
g[2]#!@var mana $reg[3]#!@var maxmana $reg[4]#!@var mv $reg[5]#!@var tnl $reg[6]#!@var exits $reg[7]#!@var hpp $hp/$maxhp*100
</pre>
Найденные подвыражения помещаются в массив $reg и нумеруются слева направо начиная с 1. Поэтому инициализируем
переменные, и тут же вычисляем проценты здоровья и маны.<br>
Осталось сделать подстановку (с параметром later чтобы работало после триггера):
<pre>
    !sub {&lt;.+Exits:.+&gt;} {&lt;$hp/$hpp% $mana/$manap% $mv Tnl:$tnl Exits:$exits&gt;} later
</pre>
Теперь надо отметить наш триггер как prompt для SMC. Посмотрите его номер по команде !triggers (допустим 1) и напишите:
<pre>
	!prompt trigger 1
</pre>
P.S. Даже если вы не хотите ничего делать со своим prompt, все равно создайте на него action или триггер
с пустой командой !null, и назначьте как prompt, например:
<pre>
	!trigger {&lt;.+Exits:.+&gt;} {!null}
	!prompt trigger 1
</pre>
Большое количество возможностей SMC не будет работать, пока не задан prompt.


<h1>Убираем спам</h1>

Когда дело доходит до разборок стипа стенка на стенку, то экран заваливается спамом отблокированных
ударов, особенно если вы ассасин, а ваш противник некромант с толпой миньонов, что очень сильно отвлекает.
Давайте уберем все строки, где вы не попали, и где по вам не попали:
<pre>
	!gag {^You (parry|dodge|hand block|shield block).+} hidden
	!gag {^[A-Z].+ (parries|dodges|hand blocks|shield blocks) your .+} hidden
</pre>
Можете добавить сюда также blink, deftly evade и т.д. по вкусу :)
Аналогично можно настроить для других типов ударов и уклонений, и не только когда
деретесь вы.<br>
Еще пример - уберем с экрана резисты, которые у вас все равно почти по нулям:
<pre>
	!gag {^You are slightly toughened} hidden
</pre>

<br><br>
Теперь поговорим о бардах. Вам не надоедает видеть по 12 строк текста песен каждый раз? Мне да.
Исправим это. Предположим, что поете вы:
<pre>
You sing the deep words of Tomb of the Damned. 
'Betrayal of Cause - he rebranded his mark. 
 Look at the shrine of one heroes of Dark. 
 He rushed to comrades but he perished in fight. 
 Look at the tomb of one damned by Light.' 
</pre>
Что тут есть характерного? Песня начинается с характерного "ля-ля-ля the deep words of ля-ля-ля". Пишем
триггер, который будет выдирать имя барда и название песни:
<pre>
	!trigger {([A-Z][a-z]+) sing(s)? the deep words of (.+)\\.} {!@var singer $reg[1]#!@var songname highlight($reg[3], yellow)}
</pre>
Учите регулярные выражения :) Заодно подкрасим название песенки в характерный желтый цвет.
Теперь делаем замену (после срабатывания триггера - параметр later)
<pre>
	!sub {.+ the deep words of .+} {$singer sing(s) the deep words of $songname.} later
</pre>
Осталось скрыть текст самой песни. Используем многострочный gag. В конце строки "... the deep words of ..." включим
блокировку, а выключим уже в конце текста песни (строка начинается пробелом, затем заглавная буква, в конце строки
кавычка, после нее иногда стоит пробел (глюк Solace'а)):
<pre>
	!gag {the deep words of} vis hidden
	!gag {^ [A-Z].+'( )?$} hidden vis
</pre>
Мы здесь не добавляли .+ с обеих сторон the deep words of, так как гаги уже работают со строками целиком.

<br><br>
Это пока все! Желаю удачи!<br>
<a href=mailto:solace@ezmail.ru>Zilav</a>

</body>
</html>